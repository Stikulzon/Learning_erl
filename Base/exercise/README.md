## Упражнение №1

Эпиграф:

*Спокойствие, только спокойствие.*

*Карлсон.*

Сейчас вы начнете писать на эрланге. Но не прямо так сразу и начнете,
а сперва откроете одну из рекомендованных в первом уроке книг и
прочитаете немного, 2-3 первые главы.

Вам понадобятся такие скучные вещи, как: математические и булевые
операции, определения функций, конструкция if и bit syntax.  Я не
рассказал вам об этом, но честно предупредил, что вам придется самим
кое-что прочитать. Привыкайте с первого упражнения к обычной рутинной
жизни программиста -- находить и читать нужную информацию :)

В этом упражнении 5 заданий. Все они очень простые, делаются максимум
в 4 строки кода.  Цель упражнения:

 - научиться находить нужную информацию;
 - разобраться, как работают тесты, проверяющие это и все другие упражнения;
 - и написать немного кода на эрланге.


### Задание 1-е

Откройте модуль **task_1**. В нем вы увидите определение функции:

```
is_in_range(Val, Left, Right) ->
```

Но здесь нет реализации. Зато ниже есть тест, который проверяет эту функцию:

```
is_in_range_test() ->
    ?assertEqual(true, is_in_range(5, 2, 10)),
    ?assertEqual(true, is_in_range(5, 5, 10)),
    ?assertEqual(true, is_in_range(5, 1, 5)),
    ?assertEqual(false, is_in_range(50, 1, 5)),
    ?assertEqual(false, is_in_range(-5, 1, 5)),
    ?assertEqual(true, is_in_range(1, 1, 1)),
    ?assertEqual(false, is_in_range(1, 5, 1)),
    ok.
```

Вы наверняка догадались, что делает тест: вызывает функцию с разными
аргументами и сравнивает результат с тем значением, которое он ожидает.

И вы наверняка догадались, что должна делать эта функция.
Ну или не догадались, а прочитали комментарий:

```
%% Check is Val in range [From, To], both edges included
```

По сложившейся традиции этот комментарий, как и любые другие
комментарии в коде, как и имена функций, переменных и т.д., написан
по-английски. Рекомендую придерживаться этой традиции :)

Если вдруг вы не догадались, и не смогли прочитать комментарий, то
поясняю: функция проверяет, находится ли ее первый аргумент в
диапазоне значений, заданном вторым и третьим аргументом,
включительно.

Я специально поместил тест прямо под функцией, чтобы вы видели,
как вызывается функция, и какие результаты ожидаются. Теперь вам
нужно написать реализацию так, чтобы она прошла тест.

Тест запускается из терминала:

```
make test_1
```

Вы можете увидеть либо

```
1>   Test passed.
result: ok
```

если написали реализацию правильно. Либо что-то такое:

```
1> task_1: is_in_range_test (module 'task_1')...*failed*
in function task_1:'-is_in_range_test/0-fun-0-'/1 (task_1.erl, line 18)
in call from task_1:is_in_range_test/0 (task_1.erl, line 18)
**error:{assertEqual_failed,[{module,task_1},
                     {line,18},
                     {expression,"is_in_range ( 5 , 2 , 10 )"},
                     {expected,true},
                     {value,false}]}
```

Это значит, что в строке 18 при вызове **is_in_range ( 5 , 2 , 10 )**
тест ожидал получить true, а вместо этого получил false.
Значит, ваша реализация неправильная.

Еще может так получится, что ваш код не скомпилируется. Тогда в терминале
вы увидите что-то такое:

```
task_1.erl:13: syntax error before: '.'
```

Тогда ищите синтаксическую ошибку в строке 13 модуля task_1 :)


### Задание 2-е

В модуле **task_2** нужно реализовать функцию **is_equal/3**, которая
сравнивает два float значения на равенство с допустимой
погрешностью. Погрешность передается 3-м аргументом.

Под определением функции вы также видите тест.
Он запускается из терминала так:

```
make test_2
```


### Задание 3-е

В модуле **task_3** нужно реализовать функцию **distance/2**,
которая вычисляет расстояние между двумя точками.
Точки заданны кортежем вида {X, Y}.

Я думаю, вы уже догадались, как запускается тест :)


### Задание 4-е

В модуле **task_4** нужно реализовать функцию **pack_floats/3**,
которая упаковывает 3 float значения в binary с помощью bit syntax.


### Задание 5-е

В модуле **task_5** нужно реализовать функцию **get_floats/1**,
которая извлекает 3 float значения из binary с помощью bit syntax.


После того, как вы сделали все 5 заданий, вызывайте:
```
make test
```
Выполнятся все тесты для всех заданий.
